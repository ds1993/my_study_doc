## 地址空间
进程地址空间由进程可寻址的虚拟内存组成  
每个进程都有一个32位或者64位的平坦地址空间
### 内存地址
一个给定的值，要在地址空间范围之内
### 内存区域
可被访问的合法地址空间  
  
+ 进只能访问有效内存区域内的内存地址，如果一个进程访问了不在有效范围中的内存区域，或者以不正确的方式访问了有效地址，那么内存就会终止该进程，并返回段错误信息
### 内存区域对象
+ 可执行文件代码的内存映射，称为代码段
+ 可执行文件的已初始化全局变量的内存映射，成为数据段
+ 包含未初始化全局变量，也就是bss段的零页的内存映射
+ 用于进程用户空间栈的零页的内存映射
+ 共享库的代码段、数据段和bss也会被载入进程的地址空间
+ 任何的内存映射文件
+ 任何共享内存段
+ 任何匿名的内存段，比如由malloc()分配的内存  

进程地址空间的任何有效地址都只能位于唯一的区域，这些内存区域不能相互覆盖
## 内存描述符
内核使用内存描述结构体表示进程的地址空间，`mm_struct`  
`<linux/sched.h>`
### 分配内存描述符
通过`allocate_mm()`从mm_cachep slab缓存中分配得到的
### 撤销内存描述符
进程退出时，内核会调用`mmput()`函数减少内存描述符中的`mm_users`用户计数，如果用户计数降到零，将调用`mmdrop()`函数，减少`mm_count`使用计数，如果使用计数也等于零了，说明该内存描述符不再有任何使用者了，调用`free_mm()`将结构体归还到mm_cachep slab缓存中
### 内核线程
+ 内核线程没有进程地址空间，也没有相关的内存描述符——没有用户上下文
+ 当一个内核线程被调度时，内核发现它的mm域为NULL，就会保留前一个进程的地址空间，随后内核更新内核线程对应的进程描述符中的`active_mm`域，使其指向前一个进程的内存描述符，所以在需要时，内核线程便可以使用前一个进程的页表
## 虚拟内存区域
+ 由`vm_area_struct`结构体描述，定义在文件`<linux/mm_types.h>`中
+ 内存区域也经常被称作虚拟内存区域（VMAs）
+ 每一个VMA就可以代表不同类型的内存区域
### VMA标志
包含在`vm_flags`域中，反应了内核处理页面所需要遵守的行为规则
### 实际使用中的内存区域
+ `/proc/<pid>/maps`的输出显示了该进程地址空间的全部内存区域  
+ 格式

	开始-结束 访问权限 偏移 主设备号:次设备号 i节点 文件
## 页表
+ 用户程序访问一个虚拟地址时，首先需要将虚拟地址转换成物理地址，然后处理器才能解析地址访问请求，地址的转换工作需要通过查询页表才能完成
+ 地址转换需要将虚拟地址分段，使每段虚拟地址都作为一个索引指向页表，而页表项则指向下一级别的页表或者指向最终的物理页面
### 三级页表
+ 顶级页表: 页全局目录(PGD)，包含一个`pgd_t`类型数组，PGD中的表项指向二级页目录中的表项
+ 二级页表: 中间爷目录(PMD)，一个`pmd_t`类型数组，其中的表项指向PTE中的表项
+ 页表: 最后一级的页表，其中包含了`pte_t`类型的页表项，该页表指向物理页面